## 学习笔记

### 哈希表，映射，集合

#### **哈希表**

哈希表也叫散列表，其数据结构存储的是 **key -value** 键值对，能够根据 key 快速访问到 value 的数据结构。

其快速访问的原理是通过特定的映射计算函数（哈希函数），key作为函数输入，然后计算出其索引下标，然后快速访问到相应数组元素。

哈希函数有个问题：不同的值可能会计算出同样的索引，这个问题也叫 **哈希冲突**。为了解决哈希冲突，常用的方法为 **拉链法**，通过在每个数组头节点后拉出一条链表，存储所有索引下标相同的元素

其各操作复杂度如下：

| 操作 | 最好 | 最坏 |
| ---- | ---- | ---- |
| 查找 | O(1) | O(n) |
| 插入 | O(1) | O(n) |
| 删除 | O(1) | O(n) |

#### **集合**

集合用于存储不重复的序列值，其中的元素是没有顺序的。其底层实现原理和哈希表相同

### 树，二叉树，二叉搜索树

#### **树**

树是一种非线性的数据结构，其实是基于链表数据结构来实现的，只不过每个节点的指针数不限定为1个，而是根据具体条件为多个。其中节点的关系通过指针指向来体现。

#### **二叉树**

常用的树为二叉树，每个节点的孩子数最多为2个，一个节点有两个指针，分别指向其自身的左孩子和右孩子。

有关二叉树的问题都跟其遍历离不开关系，所有问题的解答都需要遍历二叉树，二叉树的遍历有

- 前序遍历：序列为 **根-左-右**
- 中序遍历：序列为 **左-根-右**
- 后序遍历：序列为 **左-右-根**
- 层次遍历，按照树的层数来遍历结点

#### **二叉搜索树**

二叉搜索树是一种特殊的二叉树，其具有如下性质：

- 左子树上的所有结点值均小于其根节点的值
- 右子树上的所有节点值均小于其根节点的值

根据二叉搜索树的性质，其中序遍历的序列为 **升序序列**。由于其性质，二叉搜索树常用于查找

### 堆，二叉堆

什么是堆呢？堆是可以迅速找到一堆数中的最大或最小值的数据结构。其中，根节点最大的堆为 **大顶堆**，根节点最小的堆为 **小顶堆**。

#### **二叉堆**

堆的底层实现有多种，其中常见的为使用完全二叉树来实现堆。二叉堆（大顶）需要满足以下性质：

- 是一颗完全二叉树
- 树中任意结点的值总是 >= 其子节点中的值

由于需要维护大顶堆性质，需要相应的操作来保证该性质

- 对于插入操作，新元素放到末尾，然后对其进行向上调整, `siftUp()`
- 对于删除操作，将堆顶元素取出，然后使用堆尾元素放到堆顶，然后进行向下调整，`siftDown()`

各种操作复杂度如下：

| 操作       | 时间复杂度 |
| ---------- | ---------- |
| 插入       | O(logn)    |
| 删除       | O(logn)    |
| 取堆顶元素 | O(1)       |

### 图

什么是图呢？图是一系列顶点和边的集合定义，

- 对于顶点，需要定义顶点的度（入度和出度），以及点与点之间的连通性
- 对于边，需要定义边的方向（有向和无向），边上的权重

根据顶点和边的定义，图可以分为

- 无向无权图，无向有权图
- 有向无权图，有向有权图

我们如何表示图呢？图的表示方法有两种

- 邻接矩阵
- 邻接

对于邻接矩阵而言，`matrix[i][j]` 表示顶点 i, j 的连通性或者边的权重。邻接矩阵对于检查两顶点之间是否连通以及得到一个顶点的所有连通顶点很方便。但是对于一些稀疏图，其存储方式比较浪费空间

对于邻接表，其每个顶点作为头节点，而后连接一个链表，链表结点表示其相邻的结点和边权重。邻接表存储省空间，得到一个顶点的连通点很方便，但是若要检查两个顶点之间是否连通，需要遍历所有链表结点

#### **图的遍历**

通常对于图的问题求解，都需要对图进行遍历，图的遍历算法有

- 广度优先遍历
- 深度优先遍历

广度优先遍历要求顺序遍历当前结点的连接结点，使用队列作为队列作为辅助结构，其跟二叉树的层次遍历类似，具有层次扩展的特性

深度优先搜索类似于递归，沿着当前结点一直往下遍历直到没有连接结点或访问到重复的结点。

不管是广搜还是深搜，我们需要注意在遍历图时会访问到重复结点，因此需要一个标记数组 **visited[]** 来记录已经访问过的结点，防止结点重复访问

在广搜和深搜的基础上，衍生出了常用的图的高级算法，有

- 连通图（并查集）
- 拓扑排序
- 最短路径
- 最小生成树

根据实际场景，选择适当的遍历算法来解决图的问题

### HashMap

- HashMap 存储数据是根据键值对存储数据的，并且存储多个数据时，数据的键不能相同，如果相同该键之前对应的值将被覆盖。注意如果想要保证 HashMap 能够正确的存储数据，请确保作为键的类，已经正确覆写了 `equals()` 方法。
- HashMap 存储数据的位置与添加数据的键的 `hashCode()` 返回值有关。所以在将元素使用 HashMap 存储的时候请确保你已经按照要求重写了 `hashCode()`方法。
- HashMap 最多只允许一条存储数据的键为 null，可允许多条数据的值为 null。
- HashMap 存储数据的顺序是不确定的，并且可能会因为扩容导致元素存储位置改变。因此遍历顺序是不确定的。
- HashMap 是线程不安全的，如果需要再多线程的情况下使用可以用 `Collections.synchronizedMap(Map map)` 方法使 HashMap 具有线程安全的能力，或者使用 `ConcurrentHashMap`。

### JDK1.8 和 JDK1.7 HashMap存储数据的不同

- JDK1.7之前的存储结构
  - 「hash碰撞」时，采用「拉链法」来存储数据，新添加进来的元素总是放在数组相应的角标位置，而原来处于该角标的位置的节点作为 next 节点放到新节点的后边。
- JDK1.8中的存储结构
  - 「hash碰撞」时，不单单是使用数组加上单链表的组合了，因为如果 hash  值冲突较多的情况下，链表的长度就会越来越长，此时通过单链表来寻找 Key 对应的 Value 的时候就会使得时间复杂度达到 O(n)，因此在  JDK1.8 之后，在链表新增节点导致链表长度超过 `TREEIFY_THRESHOLD = 8` 的时候，就会在添加元素的同时将原来的单链表转化为红黑树。红黑树是一种易于增删改查的二叉树，他对与数据的查询的时间复杂度是 O(logn) 级别，所以利用红黑树的特点就可以更高效的对 HashMap 中的元素进行操作。